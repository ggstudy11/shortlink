# 短链接跳转设计方案

### 1. 背景与目标

*   **1.1. 功能概述**
    *   短链接跳转是系统的核心功能，负责将用户的短链接请求重定向到原始的长链接地址。同时需要在后台收集短链接跳转的一些监控数据(异步化)
    **1.2. 原理概述**
    *   系统通过 HTTP 302 临时重定向* 的方式将用户从短链接跳转到目标长链接。 选择 302 而不是 301 的核心原因在于，302 状态码告诉浏览器本次跳转是临时的，浏览器不会对该重定向进行缓存。 
    *   这样可以确保用户每一次访问短链接时，请求都会真实地到达我们的服务器。从而使我们能够完整地采集到每一次访问的监控指标（如 PV、UV、IP、设备信息等），为后续的数据分析提供坚实的基础。 
    *   如果错误地采用了 301 永久重定向，浏览器在第一次访问后就会缓存跳转关系，导致后续的访问请求不再经过我们的服务器，我们将因 此丢失宝贵的统计数据*，这与短链接系统的核心业务目标相悖。
*   **1.3. 设计目标**
    *   **低延迟：** 用户访问短链接后，必须在极短的时间内完成重定向，这是影响用户体验的关键。
    *   **高并发：** 系统必须能够承受热门链接带来的瞬时高并发访问压力。
    *   **高可用：** 跳转服务作为核心服务，必须保证高可用性。

### 2. 核心挑战

*   **2.1. 大流量冲击**
    *   热点事件或营销活动可能导致某个短链接在短时间内被大量访问，对后端服务造成巨大冲击。
*   **2.2. 缓存的经典问题**
    *   **缓存穿透：** 大量请求访问系统中不存在的数据（如恶意构造的短链接），导致请求绕过缓存，直接打到数据库，造成数据库压力剧增。
    *   **缓存击穿：** 某个热点链接的缓存恰好在此时失效，所有并发请求都直接涌向数据库，可能导致数据库崩溃。
    *   **缓存雪崩：** 大量缓存项在同一时间集体失效，导致数据库压力瞬间增大。

### 3. 整体设计思路

*   **3.1. 核心理念**
    最大限度地利用缓存来响应用户请求，将非核心的、耗时的操作（如统计分析）异步化处理。
*   **3.2. 请求处理流程图**
    ```mermaid
        graph LR
        A[用户请求] --> B[Nginx];
        B[Nginx] --> C[Gateway];
        C[Gateway] --> D[短链接服务];
        D[短链接服务] --> E[布隆过滤器];
        E[布隆过滤器] --> F[Redis缓存];
        F[Redis缓存] --> G[分布式锁];
        G[分布式锁] --> H[数据库];
    ```

### 4. 详细设计

*   **4.1. 布隆过滤器过滤**
    *   **目的：** 拦截绝大多数不存在的短链接请求，防止缓存穿透。
    *   **实现：**
        *   在短链接创建时，将其 `fullShortUrl` 添加到 `Redisson` 实现的分布式布隆过滤器中。
        *   在收到跳转请求时，首先检查布隆过滤器。如果 `fullShortUrl` 不存在，则直接判定为非法请求，跳转到404页面，不再进行后续查询。

*   **4.2. Redis 缓存**
    *   **目的：** 存储已知的短链接映射关系，承载绝大部分的有效读请求。
    *   **实现：**
        *   使用 Redis 的 String 类型。
        *   **Key:** `short-link:shortUrl:{fullShortUrl}`
        *   **Value:** `原始长链接地址`
        *   如果缓存命中，则直接获取原始链接，执行 4.5 节的异步统计逻辑，然后重定向。

*   **4.3. 数据库查询与防击穿设计**
    *   **目的：** 当缓存未命中时，安全地查询数据库，并防止缓存击穿。
    *   **实现：**
        *   **使用分布式锁：** 当缓存未命中时，通过 `RedissonClient` 获取一个与 `fullShortUrl` 绑定的分布式锁。
        *   **获取锁成功：**
            1.  查询数据库获取原始链接。
            2.  **回填缓存：** 将查询结果写入 Redis 缓存，并根据链接的有效期设置合理的缓存过期时间。
            3.  **空值缓存：** 如果数据库中也查询不到（例如链接已删除或过期），则在 Redis 中缓存一个特殊的**空值**（`"-"`），并设置一个较短的过期时间（30秒）。这可以进一步防止对同一个无效链接的重复数据库查询。
        *   **获取锁失败：**
            1.  说明已有其他线程在查询数据库，当前线程只需短暂等待，然后再次尝试从缓存获取即可。

*   **4.4. 异步化访问统计**
    *   **目的：** 将耗时的统计操作与主流程解耦，保证跳转性能。
    *   **实现：**
        *   在确认链接有效并即将跳转前，收集访客信息（IP、User-Agent、UV标识等）。
        *   将这些信息封装成 `StatsMessage` 对象，通过 `RabbitMQ` 发送出去。
        *   由独立的消费者服务 (`StatsConsumer`) 负责后续的数据入库和聚合统计。

*   **4.5. 最终跳转与异常处理**
    *   **成功跳转：** 使用 `HttpServletResponse.sendRedirect()` 方法，将用户重定向到原始链接。
    *   **未找到链接：** 如果经过以上所有步骤仍未找到有效链接，则统一重定向到 `/page/notfound` 页面，给用户一个明确的提示。

### 5. 关键监控指标

TODO