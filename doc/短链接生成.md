# 短链接生成设计方案

## 1. 背景

在短链接系统中，核心功能是为每一个长链接（Long URL）生成一个全局唯一、简短且不重复的短链接（Short URL）。这个过程的核心是**短链接的生成策略**，它必须满足以下要求：

*   **唯一性**：每个长链接都应映射到一个唯一的短链接，不能出现冲突。
*   **高性能**：能够快速地生成短链接，满足高并发下的创建请求。
*   **高可用**：生成服务必须稳定可靠，不能成为整个系统的单点故障。
*   **简短性**：生成的短链接后缀（如 `dwz.cn/XyZ123` 中的 `XyZ123`）应尽可能短，以方便用户分享和输入。

## 2. 核心生成方案选型

目前业界主流的短链接生成方案主要有以下几种：

### 2.1. 方案一：哈希算法 (Hash + Base62)

*   **原理**：对长链接字符串进行哈希运算（如MD5、MurmurHash），取哈希结果的一部分，然后通过Base62编码转换成短字符串。
*   **优点**：
    *   算法简单，可以做到对同一长链接生成相同的短链接。
*   **缺点**：
    *   **哈希冲突**：这是最致命的问题。理论上，任何哈希算法都无法完全避免冲突（两个不同的长链接产生相同的哈希值）。一旦冲突，就必须设计一套复杂的冲突解决机制（如在末尾追加字符再试），这会大大增加系统复杂性。

### 2.2. 方案二：UUID

*   **原理**：调用系统的UUID生成函数，取其一部分作为短链接。
*   **优点**：
    *   实现简单，本地生成，性能好。
    *   基本不会重复。
*   **缺点**：
    *   **太长**：UUID字符串（如 `a8bde211-6148-438b-8426-2395e3b8e516`）即使截取一部分也依然很长，违背了短链接的初衷。

### 2.3. 方案三：全局发号器 (自增ID + Base62)

*   **原理**：维护一个全局的、自增的数字ID。每当有新的长链接进来，就给它分配一个唯一的数字ID（1, 2, 3, ...），然后将这个数字ID转换为Base62编码的字符串。
*   **优点**：
    *   **绝对唯一**：ID严格递增，从根本上杜绝了冲突的可能。
    *   **最短链接**：ID从1开始，可以生成最短的链接（1 -> b, 10 -> k, 100 -> bM）。
*   **缺点**：
    *   **实现复杂**：核心挑战在于如何实现一个**高可用、高性能**的全局发号器（ID Generator）。

### 2.4. 选型结论

| 方案 | 唯一性 | 长度 | 性能 | 实现复杂度 |
| :--- | :--- | :--- | :--- | :--- |
| 哈希算法 | **有冲突风险** | 较长 | 一般 | 复杂（需解决冲突） |
| UUID | 几乎唯一 | **过长** | 好 | 简单 |
| **自增ID + Base62** | **绝对唯一** | **最短** | **优秀** | **较高（核心是发号器）** |

综合对比，**“自增ID + Base62”** 是最优方案。它能生成最短、唯一的链接，且对数据库友好。虽然实现一个强大的分布式发号器有挑战，但一旦解决，收益是巨大的。因此，我们选择此方案，并将设计的重点聚焦在如何实现这个发号器上。

## 3. 分布式ID生成器实现：Leaf-Segment

为了实现一个高性能、高可用的分布式自增ID生成器，我们排除了依赖时钟的Snowflake算法(因为Snowflake算法生成的64位数经过Base62编码后短码部分太长，不符合需求)，最终选择**美团开源的Leaf-Segment方案**。

### 3.1. 核心思想：数据库号段模式

Leaf-Segment的核心思想是**“数据库号段模式”**。它不再是每次需要ID时都去访问数据库，而是一次性从数据库获取一个“号段”(Segment)，然后在服务节点的内存中进行ID的分配。

例如，ID生成服务从数据库获取了一个号段 `[1000, 2000)`，那么接下来的1000次ID生成请求都可以在内存中直接完成，无需访问数据库。当这个号段消耗到一定程度时，服务会**异步地**去申请下一个号段，确保内存中始终有可用的ID储备。

这种设计带来了以下好处：

1.  **高性能**：ID生成完全是内存操作，速度极快。
2.  **高可用**：对数据库的访问频率极低。即使数据库短暂故障，服务依然可以依靠内存中的号段继续提供服务，容灾能力强。

### 3.2. 数据库设计

为了实现号段模式，我们需要在数据库中创建一张专门用于存储号段信息的表。

**表结构 (`leaf_alloc`)**

```sql
CREATE TABLE `leaf_alloc` (
  `biz_tag` varchar(128) NOT NULL DEFAULT '', -- 业务标识，用于区分不同业务的ID
  `max_id` bigint(20) NOT NULL DEFAULT '1', -- 当前已分配出去的最大ID
  `step` int(11) NOT NULL, -- 每个号段的步长（大小）
  `description` varchar(256) DEFAULT NULL, -- 业务描述
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 更新时间
  PRIMARY KEY (`biz_tag`)
) ENGINE=InnoDB;
```

### 3.3. 获取ID流程（双Buffer设计）

Leaf-Segment采用**双Buffer**设计，来消除因获取下一个号段可能导致的性能抖动。
当一个Buffer中的ID被消耗超过阈值时，服务会立刻异步启动一个线程去获取下一个号段，加载到另一个Buffer中，从而实现平滑切换，保证ID生成过程无阻塞。

## 4. ID到短链接字符串的转换：Base62编码

从Leaf获取到全局唯一的数字ID后，我们需要将其转换为由 `[0-9, a-z, A-Z]` 组成的62个字符的字符串。这个过程就是**Base62编码**。

**原理**：本质上是10进制到62进制的转换。

*   **编码**：对数字ID反复进行“除62取余”操作，将得到的余数映射到字符表中的相应字符，然后将结果字符串反转。
*   **解码**：将Base62字符串的每一位乘以62的相应次方，然后求和。

**示例**：
ID `10000` -> Base62 -> `gN3`

## 5. 系统集成

1.  **引入依赖**：在`shortlink-project`的`pom.xml`中，引入Leaf-Core的依赖。
2.  **数据库配置**：在项目中配置数据源，并执行`leaf_alloc.sql`脚本，初始化`leaf_alloc`表。
3.  **初始化数据**：向`leaf_alloc`表中插入短链接业务的`biz_tag`记录。

    ```sql
    INSERT INTO leaf_alloc(biz_tag, max_id, step, description) VALUES ('shortlink-generator', 1, 1000, 'Shortlink ID Generator');
    ```
4.  **服务调用**：在短链接生成服务中，先通过Leaf获取ID，然后进行Base62编码，最后将长链接、短链接等信息入库。

## 6. 可能的风险

*   **数据库单点故障**：虽然Leaf对数据库的依赖很弱，但如果数据库长时间宕机，当内存中的号段全部用完后，服务将无法获取新的ID。
*   **Step步长设置**：`step`的设置需要权衡。
    *   `step`过小：会导致频繁访问数据库，增加DB压力。
    *   `step`过大：如果服务重启，内存中未使用的ID将会被浪费。
    *   **应对策略**：根据业务QPS进行压测和估算，设置一个合理的`step`值。例如，预估峰值QPS为1000/s，希望一个号段能支撑10分钟，则`step`可设置为 `1000 * 60 * 10 = 600000`。